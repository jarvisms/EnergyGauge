<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
  font-family: 'Lato';
  font-style: normal;
  font-weight: 400;
  src: local('Lato Regular'), local('Lato-Regular'), url('Lato.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
* {
  margin: 0;
  padding: 0;
  border: 0;
}

body,
html {
  width: 100%;
  height: 100%;
  margin: 0px auto;
  background-image: url('Background.jpg');
  font-family: Verdana, Geneva, sans-serif;
  font-size: 12px;
  color: #ccc;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  //overflow: hidden;
}
svg {
  border: 1px solid black;
}
</style>
</head>
<body>
<div id="Gauge1" style="width:75%"></div>

<script>
function extend(obj, src) {
  Object.keys(src).forEach(function(key) { obj[key] = src[key]; });
  return obj;
}
function setAttributes(el, attrs) {
  for(var key in attrs) {el.setAttribute(key, attrs[key]);}
}
function setProperties(el, props) {
  for(var key in props) {el[key] = props[key];}
}
function addElement(doc, parentId, elementTag, elementId) {
    // Adds an element to the document and returns it
    var p = doc.getElementById(parentId);
    var newElement = doc.createElement(elementTag);
    newElement.setAttribute('id', elementId);
    p.appendChild(newElement);
    return newElement
}
function removeElement(doc, elementId) {
    // Removes an element from the document
    var element = doc.getElementById(elementId);
    element.parentNode.removeChild(element);
}
var units = " KW";
var starthue = 120;  // Green at 0%
var endhue = 0; // Red at 100%
var sat = 100;  // Saturation
var lum = 50;   // Luminance
var animAttr = {"attributeType":"XML", "dur":"1s", "fill":"freeze", "calcMode":"spline", "keyTimes":"0;1", "keySplines":"0.5 0 0.5 1"};
var Gauge1 = {};
Gauge1.div = document.getElementById("Gauge1");
Gauge1.div.innerHTML = `<svg viewBox="0 0 205 105" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
  <defs>
  <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
    <feOffset dx="5" dy="5" in="SourceGraphic" result="offOut"/>
    <feColorMatrix result="matrixOut" in="offOut" type="matrix" values="0.1 0 0 0 0  0 0.1 0 0 0  0 0 0.1 0 0  0 0 0 0.75 0"/>
    <feGaussianBlur stdDeviation="2" in="matrixOut" result="blurOut"/>
    <feBlend in="SourceGraphic" in2="blurOut" mode="normal"/>
  </filter>
  </defs>
  <path id="gaugeFace" filter="url(#shadow)">
    <animate id="lineLengthAnim" attributeName="stroke-dashoffset"/>
    <animate id="lineColourAnim" attributeName="stroke" begin="lineLengthAnim.begin"/>
    <animate id="faceColourAnim" attributeName="fill" begin="lineLengthAnim.begin"/>
  </path>
  <text id="title" filter="url(#shadow)" opacity=0 text-anchor="middle" x="100" y="95" fill="black" font-family="Lato,'Lucida Console', Monaco, monospace" font-size="16px">
    <animate id="titleAnim" attributeName="opacity" begin="lineLengthAnim.begin"/>
    Live Data!
  </text>
  <text id="label" filter="url(#shadow)" opacity=0 text-anchor="middle" x="100" y="66" fill="black" font-family="Lato,'Lucida Console', Monaco, monospace" font-size="20px">
    <animate id="labelAnim" attributeName="opacity" begin="lineLengthAnim.begin"/>
    Reading...
  </text>
</svg>`;
Gauge1.svg = Gauge1.div.getElementsByTagName("svg")[0];
Array.from(Gauge1.svg.getElementsByTagName("animate")).forEach(function (item){setAttributes(item,animAttr);}) ;
Gauge1.label = Gauge1.svg.getElementById("label");
Gauge1.gaugeFace = Gauge1.svg.getElementById("gaugeFace");
Gauge1.lineLengthAnim = Gauge1.svg.getElementById("lineLengthAnim");
Gauge1.lineColourAnim = Gauge1.svg.getElementById("lineColourAnim");
Gauge1.faceColourAnim = Gauge1.svg.getElementById("faceColourAnim");

function Draw(obj){
  var h = obj.svg.viewBox.baseVal.height-5;
  var w = obj.svg.viewBox.baseVal.width-5;
  var s =  w/10;
  var strokecolour = "hsla("+starthue+","+sat+"%,"+lum+"%,1)";    // Line Colour at 0%
  var facecolour = "hsla("+starthue+","+sat+"%,"+lum+"%,0.25)";   // Face Colour at 0%
  var arcd = ["M",s/2,h,"a",(w/2)-s,h-s,0,0,1,w-s,0];
  obj.gaugeFace.setAttribute("d", arcd.join(" "));
  var totlen = obj.gaugeFace.getTotalLength();
  setProperties(obj.gaugeFace.style,{
    "fill": "hsla("+starthue+","+sat+"%,"+lum+"%,0)",// Fade in from nothing, alpha=0
    "stroke": "hsla("+starthue+","+sat+"%,"+lum+"%,0)",// Fade in from nothing, alpha=0
    "stroke-width": s,
    "stroke-dasharray": totlen,
    "stroke-dashoffset": totlen,
  });
  setAttributes(obj.lineLengthAnim,{
    "from": totlen,
    "to": totlen,
  });
  setAttributes(obj.lineColourAnim,{
    "from": obj.gaugeFace.style.stroke,
    "to": strokecolour,
  });
  setAttributes(obj.faceColourAnim,{
    "from": obj.gaugeFace.style.fill,
    "to": facecolour,
  });
  var titleAnim = obj.svg.getElementById("titleAnim");
  setAttributes(titleAnim,{
    "from": 0,
    "to": 1,
  });
  titleAnim.onend = () => {
    title.setAttribute("opacity",1);  // Keep it permanent
    titleAnim.parentNode.removeChild(titleAnim);
    title.textContent = "Live Elec";
  }
  var labelAnim = obj.svg.getElementById("labelAnim");
  setAttributes(labelAnim,{
    "from": 0,
    "to": 1,
  });
  labelAnim.onend = () => {
    obj.label.setAttribute("opacity",1);  // Keep it permanent
    labelAnim.parentNode.removeChild(labelAnim);
    obj.label.textContent = "-.--"+units;
  }
  obj.lineLengthAnim.beginElement();
}

function Update(obj,rawval,max) {
  rawval = parseFloat(rawval);
  var percent = rawval / max;
  // Keep the percentages within limits
  if (percent < 0) percent = 0;
  else if (percent > 100) percent = 100;
  var offset = obj.gaugeFace.getTotalLength() * (1-percent);
  var newhue = starthue - (starthue-endhue) * percent;
  setAttributes(obj.lineLengthAnim,{
    "from": obj.lineLengthAnim.getAttribute("to"),
    "to": offset,
  });
  setAttributes(obj.lineColourAnim,{
    "from": obj.lineColourAnim.getAttribute("to"),
    "to": "hsla("+newhue+","+sat+"%,"+lum+"%,1)",
  });
  setAttributes(obj.faceColourAnim,{
    "from": obj.faceColourAnim.getAttribute("to"),
    "to": "hsla("+newhue+","+sat+"%,"+lum+"%,0.25)",
  });
  obj.label.textContent = rawval.toFixed(2)+units
  obj.lineLengthAnim.beginElement();
}

lineLengthAnim.onend = () => Update(Gauge1,Math.random()*50.0,50.0);

Draw(Gauge1);

// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};
</script>

</body>
</html>




